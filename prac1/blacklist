#include <string.h>

#include <fstream>
#include <iostream>
#include <queue>
#include <set>
#include <unordered_map>
#include <vector>

enum AutoType { kNondeterministic = 0, kDeterministic = 1, kComplete = 2 };
enum NodeType { kStart = 0, kNone = 1, kTerminal = 2 };

template <AutoType T>
class AutomatonT {
 private:
  struct Node {
    size_t id;
    std::unordered_map<std::string, std::vector<size_t>> go;
    node_type type = none;

    void AddEdge(int to, const std::string& word) { go[word].push_back(to); }
  };

 public:
  automaton_t(std::set<std::string>& sigma) : m_sigma_(sigma) {}

  automaton_t& operator=(automaton_t&) = delete;

  size_t Size() const { return m_node_cnt_; }

  std::set<std::string>& GetSigma() const { return m_sigma_; }

 protected:
  // bool IsNodeExists(int index) {
  //   return m_nodes_set_.find(ptr) != m_nodes_set_.end();
  // }

  // bool IsNodeExists(const std::string& node_id) {
  //   return m_map_.find(node_id) != m_map_.end();
  // }

  int CreateNode() {
    if (IsNodeExists(node_id)) {
      return m_map_[node_id];
    }
    m_nodes_.push_back(new Node(node_id));
    m_map_[node_id] = m_nodes_.back();
    ++m_node_cnt_;
    return m_nodes_.back();
  }

  void AddEdge(Node* ptr_from, Node* ptr_to, const std::string& word = "#") {
    ptr_from->AddEdge(ptr_to, word);
  }

  void AddEdge(const std::string& from_id, const std::string& to_id,
               const std::string& word = "#") {
    if (!IsNodeExists(from_id)) {
      CreateNode(from_id);
    }
    if (!IsNodeExists(to_id)) {
      CreateNode(to_id);
    }
    Node* from = m_map_[from_id];
    Node* to = m_map_[to_id];
    from->AddEdge(to, word);
  }

  void SetStartNode(Node* ptr) { ptr->type_n = start; }

  void SetStartNode(const std::string& node_id) {
    if (!IsNodeExists(node_id)) {
      CreateNode(node_id);
    }
    m_start_node_ = m_map_[node_id];
    m_start_node_->type_n = start;
  }

  void SetTerminalNode(Node* ptr) { ptr->type_n = terminal; }

  void SetTerminalNode(const std::string& node_id) {
    if (!IsNodeExists(node_id)) {
      CreateNode(node_id);
    }
    Node* temp = m_map_[node_id];
    temp->type_n = terminal;
  }

  friend class AutomatonBuilder;
  friend class AutomatonTransform;

  size_t m_node_cnt_ = 0;
  size_t m_start_node_id_;
  std::vector<Node> m_nodes_;
  std::set<std::string> m_sigma_;
};
// std::unordered_map<std::string, std::vector<Node*>> map_n;

/*Node* m_start_node_ = nullptr;
  std::vector<Node*> m_nodes_;
  std::unordered_map<std::string, Node*> m_ptr_by_str_;
  std::unordered_set<Node*> m_nodes_set_;
  std::set<std::string> m_sigma_;;*/

class AutomatonTransform {
  using Node_t = automaton_t<nondeterministic>::Node;

  size_t cnt = 0;

  void HelperBFS(Node_t* cur, std::unordered_map<Node_t*, Node_t*>& from_to,
                 std::unordered_map<Node_t*, bool>& visited,
                 automaton_t<nondeterministic>& zero_one_letter) {
    std::queue<Node_t*> q;
    q.push(cur);
    while (!q.empty()) {
      cur = q.front();
      q.pop();
      Node_t* st = from_to[cur];
      st->type_n = cur->type_n;
      visited[st] = true;
      for (auto it = cur->map_n.begin(); it != cur->map_n.end(); ++it) {
        std::string word = it->first;
        for (auto it1 = it->second.begin(); it1 != it->second.end(); ++it1) {
          if (from_to.find(*it1) == from_to.end()) {
            from_to[*it1] = zero_one_letter.CreateNode(std::to_string(cnt++));
          }
          Node_t* fn = from_to[*it1];
          if (word.length() > 2) {
            for (int i = 0; i < word.length() - 1; ++i) {
              Node_t* temp = zero_one_letter.CreateNode(std::to_string(cnt++));
              st->AddEdge(temp, std::string(1, word[i]));
              st = temp;
            }
            st->AddEdge(fn, std::string(1, word[word.length() - 1]));
            if (visited.find(fn) == visited.end()) {
              q.push(fn);
            }
          } else {
            st->AddEdge(fn, word);
            if (visited.find(fn) == visited.end()) {
              q.push(*it1);
            }
          }
        }
      }
    }
  }

 public:
  automaton_t<nondeterministic> Make01Symbols(
      const automaton_t<nondeterministic>& source) {
    automaton_t<nondeterministic> zero_one_letter(source.GetSigma());
    using Node_t = automaton_t<nondeterministic>::Node;

    Node_t* cur = source.m_start_node_;
    std::unordered_map<Node_t*, Node_t*> from_to;
    std::unordered_map<Node_t*, bool> visited;

    from_to[cur] = zero_one_letter.CreateNode(std::to_string(cnt++));
    HelperBFS(cur, from_to, visited, zero_one_letter);
    return zero_one_letter;
  }

  automaton_t<nondeterministic> WithoutEPS(
      const automaton_t<nondeterministic>& source) {
    automaton_t<nondeterministic> without_eps(source.GetSigma());
  }
};

class AutomatonBuilder {
  using Node_t = automaton_t<nondeterministic>::Node;

 public:
  virtual automaton_t<nondeterministic> StreamBuildAutomaton(
      std::ifstream& in) {
    std::set<std::string> sigma;
    std::string s;
    in >> s;
    if (s == "Sigma:") {
      in >> s;
      while (s != "#") {
        sigma.insert(s);
        in >> s;
      }
    }

    automaton_t<nondeterministic> automaton(sigma);
    in >> s;
    if (s == "Start:") {
      in >> s;
      automaton.SetStartNode(s);
    }
    in >> s;
    if (s == "Acceptance:") {
      in >> s;
      while (s != "#") {
        automaton.SetTerminalNode(s);
        in >> s;
      }
    }
    in >> s;
    if (s == "--BEGIN--") {
      in >> s;
      while (s != "--END--") {
        std::string from;
        if (s == "State:") {
          in >> from;
        } else if (s == "->") {
          std::string word, to;
          in >> word >> to;
          if (word == "EPS") {
            word = "#";
          }
          automaton.AddEdge(from, to, word);
        } else {
          throw std::exception();
        }
        in >> s;
      }
    }
    return automaton;
  }
  // std::unordered_map<std::string, std::vector<Node*>> map_n;

  /*std::vector<Node*> m_nodes_;
  std::unordered_map<std::string, size_t> m_map_;
  std::set<std::string> m_sigma_;*/

  virtual automaton_t<deterministic> BuildDeterministic(
      const automaton_t<nondeterministic>& source) = 0;
  virtual automaton_t<complete> BuildComplete(automaton_t<deterministic>) = 0;
};

/*
Sigma: a b c d e #
Start: 1
Acceptance: 2 3 #
--BEGIN--
State: 1
    -> a 2
State: 2
    -> b 2
    -> EPS 3
State: 3
    -> aba 3
    -> a 4
State: 4
    -> ab 4
    -> a 2
--END--
*/